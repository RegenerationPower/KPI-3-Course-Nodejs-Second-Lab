# Nodejs lab 2

## Виконали:

- студент групи ІА-04 Сергій Яцук
- студент групи ІО-04 Возниця Дмитро
- студент групи ІО-04 Нерода Арсен

## Контрольні питання

1. **В чому різниця між setTimeout i setInterval?**
   <br>
   Різниця між `setTimeout()` і `setInterval()` полягає в тому, що `setTimeout()` запускає виклик функції один раз. У той час як `setInterval()` запускає функцію кілька разів через заданий інтервал часу. Тобто запустивши функцію через `setTimeout()` ми отримаєио її разове виконання через певний проміжок часу, в той час як зробивши це через `setInterval()` функція буде повторятися з паузою в певний проміжок часу.
   <br>
2. **Що таке блокуючий код?**
   <br>
   Блокуючий код - це код який вимагає призупинення програми задля виконання певної операції. Тобто виконання NodeJS коду призупинено до тих пір поки не виконається певна операція, наприклад читання з файлу або ж запис туди, чи вигрузка даних. Вирішенням блолкуючого коду є використання асинхронних засобів програмування.
   <br>
3. **Які переваги асинхронного читання з диску перед синхронним?**
   <br>
   В асинхронному програмуванні з диском основна перевага полягає в тому, що воно дозволяє багатоопераційне введення-виведення (I/O) здійснювати без блокування потоку виконання. У синхронному програмуванні з диском, якщо диск затримує відповідь, виконання програми зупиняється і чекає на відповідь диска. В асинхронному програмуванні з диском, коли виконання програми зустрічає I/O-операції, воно запускає їх асинхронно та не чекає на їх відповідь, а замість цього повертає управління іншим частинам програми, що продовжують виконуватись.
   <br>
4. **Опишіть різницю між Callbacks API, Promise API та async/await?**
   <br>
   Callbacks, Promises та async/await - це механізми для обробки асинхронного коду в JavaScript.
   <br>   
   Callbacks - це функції, які передаються як аргументи до інших функцій та викликаються, коли операція завершена. Callbacks - це традиційний спосіб обробки асинхронного коду в JavaScript, але може призвести до пастки коли потрібно виконати кілька асинхронних операцій.
   <br>   
   Promises - це новіша можливість мови, яка була введена в ES6. Об'єкт Promise представляє значення, яке ще не може бути доступним, але буде вирішене в майбутньому. Promises забезпечують спосіб ланцюгування асинхронних операцій та обробки помилок в стандартний спосіб. Він є більш чистим та зрозумілим способом написання асинхронного коду, ніж Callbacks.
   <br>   
   async/await - це ще більш новіша можливість мови, яка була введена в ES8. async/await - це синтаксис для написання асинхронного коду, який виглядає як синхронний код. Асинхронні функції повертають Promise і можуть використовувати ключове слово await, щоб чекати на інші асинхронні операції. async/await - це ще більш простий та зрозумілий спосіб написання асинхронного коду, ніж Promises.
   <br>
   У термінах відмінностей, Callbacks - це найнижчий рівень та найбільш обсяговий з трьох варіантів. Вони можуть призвести до callback hell, коли потрібно декілька асинхронних операцій для досягнення певної задачі. Promises забезпечують можливість писати більш чистий та зрозумілий код, який може обробляти складні ланцюжки асинхронних операцій. async/await забезпечує ще більш чистий та зрозумілий синтаксис для написання асинхронного коду, який виглядає як синхронний код, але він все ще залежить від Promises під капотом.
   <br>
5. **Як обробляються помилки при використанні Promise API?**
   <br>
   Існує кілька способів обробки помилок при використанні Promise API в JavaScript:
   <br>   
   1. Використання методу `.catch()`: Це найпоширеніший спосіб обробки помилок з Promise. Метод `.catch()` використовується для перехоплення будь-яких помилок, які виникають у ланцюжку Promise. Цей метод приймає функцію зворотнього виклику, яка буде викликана при виникненні помилки, передаючи помилку як перший аргумент.
```javascript
   myPromiseFunction()
      .then(result => {
         // do something with the result
      })
   .catch(error => {
      // handle the error
   });
```

   2. Поширення помилок: Ви також можете згенерувати помилку у методі .`then()` для того, щоб її перехопити в наступному методі `.catch()` у ланцюжку.
```javascript
   myPromiseFunction()
      .then(result => {
         if (!result) {
            throw new Error('Result is undefined');
         }
         return result;
      })
   .catch(error => {
      // handle the error
   });
```
   3. Використання Promise.all() та Promise.race(): `Promise.all()` та `Promise.race()` можуть бути використані для обробки кількох Promises одночасно. `Promise.all()` чекає, доки всі Promises не будуть вирішені або відхилені, тоді як `Promise.race()` чекає на перший Promise, який буде вирішений або відхилений. Обидва методи будуть відхилені з помилкою, якщо будь-який Promise у групі буде відхилений.
```javascript
   Promise.all([promise1, promise2, promise3])
      .then(results => {
         // handle successful results
      })
   .catch(error => {
      // handle errors
   });
```
   4. Використання async/await: Помилки також можуть бути оброблені за допомогою `async/await`, використовуючи блок try/catch.
```javascript
   async function myAsyncFunction() {
      try {
         const result = await myPromiseFunction();
         // handle the result
      } catch (error) {
         // handle the error
      }
   }
```
6. **Як створити директорію через модуль fs? За що відповідає параметр mode?**
   <br>
   Щоб створити директорію за допомогою модуля fs в Node.js, можна використовувати метод `fs.mkdir()` або `fs.mkdirSync()`. Використання асинхронної версії:
```javascript
   const fs = require('fs');

   fs.mkdir('/path/to/new/directory', (err) => {
      if (err) throw err;
      console.log('New directory created successfully.');
   });
```
   Перший аргумент `fs.mkdir()` вказує шлях до нової директорії, яку потрібно створити. Другий аргумент - це необов'язковий об'єкт опцій, який може використовуватися для встановлення прав доступу до директорії.
   <br>
   Параметр mode вказує права, які потрібно встановити для нової директорії. Це вісьмірна (октальна) значення, яке відображає права на читання, запис та виконання для власника, групи та інших. Наприклад, `0755` дає власнику права на читання, запис та виконання, а групі та іншим дозволяє читати та виконувати. Якщо параметр mode не вказаний, то буде використано значення за замовчуванням - `0777`:
```javascript
   const fs = require('fs');

   fs.mkdir('/path/to/new/directory', { recursive: true, mode: 0o755 }, (err) => {
      if (err) throw err;
      console.log('New directory created with mode 755.');
   });
```
   Використовується опція `recursive`, яка створює будь-які відсутні батьківські директорії в шляху. Параметр `mode` встановлено на `0755`, щоб дати власникові права на читання, запис та виконання, а групі та іншим - права на читання та виконання.
